/**
 * Platform Integration Service
 * Handles integrations with GitHub, Vercel, and Netlify for automated deployments
 * Note: OAuth flows require backend setup. This service provides the client-side logic.
 */

// Platform connection types
export interface PlatformConnection {
  id: string;
  platform: 'github' | 'vercel' | 'netlify';
  accessToken?: string;
  refreshToken?: string;
  projectId?: string;
  projectName?: string;
  siteUrl?: string;
  connectedAt: string;
  lastDeployAt?: string;
}

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  owner: string;
  default_branch: string;
  html_url: string;
  private: boolean;
}

export interface DeployResult {
  success: boolean;
  message: string;
  deployUrl?: string;
  deployId?: string;
}

// OAuth URLs (these would be configured with your app's client IDs)
export const OAUTH_URLS = {
  github: 'https://github.com/login/oauth/authorize',
  vercel: 'https://vercel.com/integrations/aeo-tool/new',
  netlify: 'https://app.netlify.com/authorize'
};

// Check if a platform is connected
export function isPlatformConnected(platform: 'github' | 'vercel' | 'netlify'): boolean {
  const connection = getConnection(platform);
  return connection !== null && !!connection.accessToken;
}

// Get stored connection
export function getConnection(platform: 'github' | 'vercel' | 'netlify'): PlatformConnection | null {
  try {
    const stored = localStorage.getItem(`aeo_${platform}_connection`);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
}

// Save connection
export function saveConnection(connection: PlatformConnection): void {
  localStorage.setItem(`aeo_${connection.platform}_connection`, JSON.stringify(connection));
}

// Remove connection
export function disconnectPlatform(platform: 'github' | 'vercel' | 'netlify'): void {
  localStorage.removeItem(`aeo_${platform}_connection`);
}

// Get all connections
export function getAllConnections(): PlatformConnection[] {
  const platforms: ('github' | 'vercel' | 'netlify')[] = ['github', 'vercel', 'netlify'];
  return platforms
    .map(p => getConnection(p))
    .filter((c): c is PlatformConnection => c !== null);
}

// --- GitHub Integration ---

// Generate schema injection code based on framework
export function generateSchemaInjection(
  framework: 'next' | 'gatsby' | 'html' | 'hugo' | 'other',
  schemaJson: object,
  brandName: string
): { path: string; content: string; instructions: string } {
  switch (framework) {
    case 'next':
      return {
        path: 'components/AEOSchema.tsx',
        content: `// AEO Schema Component - Generated by AEO Tool
// Add this component to your _app.tsx or layout.tsx

import Head from 'next/head';

const schema = ${JSON.stringify(schemaJson, null, 2)};

export const AEOSchema = () => (
  <Head>
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  </Head>
);

export default AEOSchema;
`,
        instructions: `1. Add this file to your components folder
2. Import and use <AEOSchema /> in your _app.tsx or layout.tsx
3. Deploy your changes`
      };

    case 'gatsby':
      return {
        path: 'src/components/AEOSchema.js',
        content: `// AEO Schema Component - Generated by AEO Tool
// Add this component to your gatsby-ssr.js

import React from 'react';
import { Helmet } from 'react-helmet';

const schema = ${JSON.stringify(schemaJson, null, 2)};

export const AEOSchema = () => (
  <Helmet>
    <script type="application/ld+json">
      {JSON.stringify(schema)}
    </script>
  </Helmet>
);

export default AEOSchema;
`,
        instructions: `1. Add this file to your src/components folder
2. Import and use <AEOSchema /> in your layout component
3. Run gatsby build && gatsby serve to test`
      };

    case 'hugo':
      return {
        path: 'layouts/partials/aeo-schema.html',
        content: `{{/* AEO Schema Partial - Generated by AEO Tool */}}
{{/* Include this in your baseof.html: {{ partial "aeo-schema.html" . }} */}}

<script type="application/ld+json">
${JSON.stringify(schemaJson, null, 2)}
</script>
`,
        instructions: `1. Add this file to layouts/partials/
2. Include in your baseof.html: {{ partial "aeo-schema.html" . }}
3. Rebuild your Hugo site`
      };

    case 'html':
    default:
      return {
        path: 'aeo-schema.html',
        content: `<!-- AEO Schema - Generated by AEO Tool -->
<!-- Copy this into your <head> section -->

<script type="application/ld+json">
${JSON.stringify(schemaJson, null, 2)}
</script>
`,
        instructions: `1. Copy the script tag above
2. Paste it into the <head> section of your HTML pages
3. Upload the updated files to your server`
      };
  }
}

// Generate llm.txt file content for deployment
export function generateLlmTxtFile(content: string): { path: string; content: string } {
  return {
    path: 'public/llm.txt',
    content: content
  };
}

// Generate PR description
export function generatePRDescription(
  brandName: string,
  schemaType: string,
  hasLlmTxt: boolean
): string {
  return `## üîç AEO Optimization PR

This PR adds structured data to improve **${brandName}**'s visibility in AI-generated answers (ChatGPT, Perplexity, Gemini).

### Changes

- **JSON-LD Schema**: ${schemaType} schema for better AI understanding
${hasLlmTxt ? '- **llm.txt**: Machine-readable brand context file' : ''}

### What This Does

1. Helps AI models understand what your product does
2. Increases likelihood of being cited in AI answers
3. Provides structured data for "best X for Y" type queries

### Next Steps

1. Review the changes
2. Merge this PR
3. After deployment, re-run AEO analysis to check improvements

---
*Generated by [AEO Tool](https://aeo.tool) ‚Äî AI Answer Visibility Checker*
`;
}

// --- Vercel Integration ---

// Deploy file to Vercel (requires access token)
export async function deployToVercel(
  accessToken: string,
  projectId: string,
  files: { path: string; content: string }[]
): Promise<DeployResult> {
  try {
    const response = await fetch('https://api.vercel.com/v13/deployments', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: projectId,
        files: files.map(f => ({
          file: f.path,
          data: btoa(f.content) // Base64 encode
        })),
        projectSettings: {
          framework: null // Inherits from project
        }
      })
    });

    if (!response.ok) {
      const error = await response.json();
      return {
        success: false,
        message: error.error?.message || `Vercel API error: ${response.status}`
      };
    }

    const data = await response.json();
    return {
      success: true,
      message: 'Successfully deployed to Vercel',
      deployUrl: data.url,
      deployId: data.id
    };
  } catch (error) {
    return {
      success: false,
      message: `Deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

// --- Netlify Integration ---

// Deploy file to Netlify (requires access token)
export async function deployToNetlify(
  accessToken: string,
  siteId: string,
  filePath: string,
  content: string
): Promise<DeployResult> {
  try {
    const response = await fetch(
      `https://api.netlify.com/api/v1/sites/${siteId}/files/${filePath}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/octet-stream'
        },
        body: content
      }
    );

    if (!response.ok) {
      const error = await response.json();
      return {
        success: false,
        message: error.message || `Netlify API error: ${response.status}`
      };
    }

    return {
      success: true,
      message: 'Successfully deployed to Netlify'
    };
  } catch (error) {
    return {
      success: false,
      message: `Deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

// --- Connection Status UI Helpers ---

export function getConnectionStatus(platform: 'github' | 'vercel' | 'netlify'): {
  connected: boolean;
  label: string;
  color: string;
} {
  const connection = getConnection(platform);
  
  if (!connection || !connection.accessToken) {
    return {
      connected: false,
      label: 'Not Connected',
      color: 'gray'
    };
  }

  return {
    connected: true,
    label: connection.projectName || 'Connected',
    color: 'emerald'
  };
}

// Platform display info
export const PLATFORM_INFO = {
  github: {
    name: 'GitHub',
    icon: 'üêô',
    description: 'Create PRs with schema fixes directly in your repository',
    features: ['Auto-create branches', 'Generate PRs with schema', 'Track merge status']
  },
  vercel: {
    name: 'Vercel',
    icon: '‚ñ≤',
    description: 'Deploy llm.txt and schema files directly to your Vercel project',
    features: ['One-click deploy', 'Auto-triggers build', 'Instant preview']
  },
  netlify: {
    name: 'Netlify',
    icon: '‚óÜ',
    description: 'Push files directly to your Netlify site',
    features: ['Direct file upload', 'No build required', 'Instant publish']
  }
};

// Generate OAuth redirect URL (for future backend integration)
export function getOAuthRedirectUrl(
  platform: 'github' | 'vercel' | 'netlify',
  clientId: string,
  redirectUri: string,
  state: string
): string {
  switch (platform) {
    case 'github':
      return `${OAUTH_URLS.github}?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&scope=repo&state=${state}`;
    case 'vercel':
      return OAUTH_URLS.vercel;
    case 'netlify':
      return `${OAUTH_URLS.netlify}?client_id=${clientId}&response_type=token&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`;
    default:
      return '';
  }
}
